#!/usr/bin/env python
#----------------------------------------------------------------------------
from sys import argv
from os import makedirs
from os.path import basename, abspath, isdir, isfile, exists, join, dirname
from shutil import rmtree
from xml.parsers.expat import ParserCreate
from mako.template import Template
from mako.lookup import TemplateLookup
from mako.runtime import Context
from StringIO import StringIO
from traceback import print_exc

ITEMS = dict()
KINDS = dict()
SEQUENCE = 1

#----------------------------------------------------------------------------
# Usage information and error reporting
#----------------------------------------------------------------------------

USAGE = """
Usage:

    %s inputdir outputdir

Where:

    inputdir  - the directory containing the XML files generated by doxygen.
    outputdir - the output directory to place the generated Jekyll files.

IMPORTANT: The output directory will be deleted prior to generating new files.
"""

def showUsage(msg = None):
  """ Show usage information and exit
  """
  if msg is not None:
    print "Error: %s\n" % msg
  print USAGE.strip() % argv[0]
  exit(1)

#----------------------------------------------------------------------------
# Documentation data model
#----------------------------------------------------------------------------

class DocItem:
  def __init__(self, **kwds):
    self.parent = None
    self.children = list()
    self.__dict__.update(kwds)

  def addChild(self, child):
    child.parent = self
    self.children.append(child)

  def getFile(self):
    """ Find the closest file object to this one
    """
    result = self
    while (result is not None) and (result.kind <> "file"):
      result = result.parent
    return result

  def getDisplayName(self):
    if self.kind in ("method", "function"):
      return "%s %s%s" % (self.type, self.name, self.argsstring)

  def getParameterDescription(self, name):
    """ Match a description to a parameter name
    """
    if hasattr(self, "paramDesc"):
      for param in self.paramDesc:
        if name in param.names:
          return param.description
    return ""

# Items grouped by various conditions
ITEMS = list()
ITEMS_BY_REFID = dict()
ITEMS_BY_KIND = dict()

def addItem(item):
  """ Add a new item
  """
  global ITEMS, ITEMS_BY_REFID, ITEMS_BY_KIND
  ITEMS.append(item)
  ITEMS_BY_REFID[item.refid] = item
  if not ITEMS_BY_KIND.has_key(item.kind):
    ITEMS_BY_KIND[item.kind] = list()
  ITEMS_BY_KIND[item.kind].append(item)

def getItem(refid):
  global ITEMS_BY_REFID
  return ITEMS_BY_REFID.get(refid, None)

#----------------------------------------------------------------------------
# XML data loading
#----------------------------------------------------------------------------

class BaseParser:
  """ Base implementation of a expat based XML parser
  """

  def __init__(self):
    """ Create the parser and attach hooks
    """
    # Use this to deliberately ignore tags without displaying output
    self.ignoreTags = list()

  #--------------------------------------------------------------------------
  # Event dispatching
  #--------------------------------------------------------------------------

  def _StartElementHandler(self, name, attributes):
    # Add to the call stack
    self._active = name
    self._stack.append(self._active)
    # Allow custom processing
    methodName = "begin%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if callable(method):
      method(name, attributes)
    else:
      if not name in self.ignoreTags:
        method = getattr(self, "begin", None)
        if callable(method):
          method(name, attributes)
        else:
          print "Unhandled tag '<%s>'" % name

  def _EndElementHandler(self, name):
    # Pop off the call stack
    self._stack = self._stack[:-1]
    if len(self._stack) > 0:
      self._active = self._stack[-1]
    else:
      self._active = None
    # Allow custom processing
    methodName = "end%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if callable(method):
      method(name)
    else:
      if not name in self.ignoreTags:
        method = getattr(self, "end", None)
        if callable(method):
          method(name)

  def _CharacterDataHandler(self, data):
    self.processText(self._active, data)

  #--------------------------------------------------------------------------
  # Parsing
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    pass

  def parse(self, filename):
    """ Parse a file
    """
    # Initialise state
    self._stack = list()
    self._active = None
    # Allow custom state initialisation
    self.beginParse()
    # Create a parser and process the file
    parser = ParserCreate()
    parser.StartElementHandler = self._StartElementHandler
    parser.EndElementHandler = self._EndElementHandler
    parser.CharacterDataHandler = self._CharacterDataHandler
    parser.ParseFile(open(filename, "r"))

  def processText(self, name, text):
    """ Called to handle text between tags
    """
    pass

class CompoundParser(BaseParser):
  """ Parser for the index.xml file generated by doxygen

    This builds up the list of top level compound objects and builds the
    initial data for their child members.
  """

  def __init__(self):
    """ Constructor
    """
    BaseParser.__init__(self)
    # Ignore these tags, we don't use them
    self.ignoreTags.append("doxygenindex")
    self.ignoreTags.append("name")
    # Build up a set of top level sources
    self.sources = list()

  #--------------------------------------------------------------------------
  # Parse handlers
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    self.activeCompound = None
    self.activeMember = None

  def processText(self, name, text):
    if name == "name":
      if self.activeMember is not None:
        self.activeMember.name = self.activeMember.name + text
      elif self.activeCompound is not None:
        self.activeCompound.name = self.activeCompound.name + text

  def beginCompound(self, name, attributes):
    self.activeCompound = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )
    # Each compound entry has a detail file associated with it
    self.sources.append("%s.xml" % self.activeCompound.refid)

  def endCompound(self, name):
    addItem(self.activeCompound)
    self.activeCompound = None

  def beginMember(self, name, attributes):
    self.activeMember = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )
    # Hack: Doxygen treats methods as functions, lets give them their own
    #       kind so we can handle it appropriately
    if (self.activeCompound.kind == "class") and (self.activeMember.kind == "function"):
      self.activeMember.kind = "method"
    # Attach to parent
    self.activeCompound.addChild(self.activeMember)

  def endMember(self, name):
    addItem(self.activeMember)
    self.activeMember = None

class DetailParser(BaseParser):
  """ Parser for the subsiduary XML files generated by doxygen
  """

  DESCRIPTION_TAGS = (
    "name",
    "briefdescription",
    "detaileddescription",
    "type",
    "definition",
    "argsstring",
    "inbodydescription",
    "declname"
    )

  def __init__(self):
    """ Constructor
    """
    BaseParser.__init__(self)
    # Ignore these tags, we don't use them
    self.ignoreTags.append("codeline")
    self.ignoreTags.append("highlight")
    self.ignoreTags.append("sp")
    self.ignoreTags.append("para")

  #--------------------------------------------------------------------------
  # Helpers
  #--------------------------------------------------------------------------

  def clearText(self):
    self.text = list()

  def addText(self, text):
    self.text.append(text)

  def getText(self):
    return " ".join(self.text)

  #--------------------------------------------------------------------------
  # Parse handlers
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    # Set state
    self.activeItem = None
    self.activeTag = None
    self.text = list()

  def processText(self, name, text):
    self.addText(text)

  def beginMemberdef(self, name, attributes):
    self.activeItem = getItem(attributes['id'])
    if self.activeItem is None:
      print "Warning: reference to unknown item '%s'" % attributes['id']
      return
    # Add attributes to the item
    for k in attributes.keys():
      if k not in ("kind", "id"):
        setattr(self.activeItem, k, attributes[k])
    # Set defaults for descriptions
    for desc in DetailParser.DESCRIPTION_TAGS:
      setattr(self.activeItem, desc, "")

  def endMemberdef(self, name):
    self.activeItem = None

  def beginRef(self, name, attributes):
    # TODO: What about references that don't get their own pages?
    self.addText('<a href="%s.html">' % attributes['refid'])

  def endRef(self, name):
    self.addText('</a>')

  def beginSimplesect(self, name, attributes):
    kind = attributes['kind']
    if kind == "return": # Can't use, it's a keyword
      kind = "returns"
    self.activeItem = DocItem(parent = self.activeItem, name = kind, text = self.text)
    self.clearText()

  def endSimplesect(self, name):
    section = self.activeItem
    self.activeItem = section.parent
    setattr(self.activeItem, section.name, self.getText())
    self.text = section.text

  def beginParam(self, name, attributes):
    self.activeItem = DocItem(
      parent = self.activeItem,
      declname = "",
      type = ""
      )
  def endParam(self, name):
    param = self.activeItem
    self.activeItem = param.parent
    if not hasattr(self.activeItem, "params"):
      self.activeItem.params = list()
    self.activeItem.params.append(param)

  def beginParameterlist(self, name, attributes):
    self.activeItem.paramDesc = list()

  def endParameterlist(self, name):
    pass

  def beginParameteritem(self, name, attributes):
    param = DocItem(
      parent = self.activeItem,
      names = list(),
      description = "",
      text = self.text
      )
    self.activeItem.paramDesc.append(param)
    self.activeItem = param
    self.clearText()

  def endParameteritem(self, name):
    self.text = self.activeItem.text
    del self.activeItem.text
    self.activeItem = self.activeItem.parent

  def beginParametername(self, name, attributes):
    self.clearText()

  def endParametername(self, name):
    self.activeItem.names.append(self.getText())

  def beginParameterdescription(self, name, attributes):
    self.clearText()

  def endParameterdescription(self, name):
    self.activeItem.description = self.getText()

  def begin(self, name, attributes):
    if name in DetailParser.DESCRIPTION_TAGS:
      self.clearText()

  def end(self, name):
    if (name in DetailParser.DESCRIPTION_TAGS) and (self.activeItem is not None):
      setattr(self.activeItem, name, self.getText())

def loadData(indir):
  """ Load the documentation data from the XML files.
  """
  print "Processing input ..."
  if not isfile(join(indir, "index.xml")):
    showUsage("Could not find 'index.xml' in input directory")
  parser = CompoundParser()
  print "  index.xml"
  parser.parse(join(indir, "index.xml"))
  # Now do all the detail files
  sources = parser.sources
  parser = DetailParser()
  for source in sources:
    print "  %s" % source
    parser.parse(join(indir, source))

#----------------------------------------------------------------------------
# Output generation
#----------------------------------------------------------------------------

def processTemplate(template, outputname, lookup, docItem = None):
  global ITEMS, ITEMS_BY_KIND, ITEMS_BY_REFID
  # Set up the context
  buf = StringIO()
  context = Context(buf,
    docItem = docItem,
    docItems = ITEMS,
    docItemsByKind = ITEMS_BY_KIND,
    docItemsByRefId = ITEMS_BY_REFID
    )
  try:
    template.render_context(context)
    with open(outputname, "w") as output:
      output.write(buf.getvalue())
  except Exception, ex:
    print "Error: Could not generate '%s'" % outputname
    print docItem.__dict__
    print_exc()

def generateDocs(outdir):
  global ITEMS
  # Figure our where our templates are
  templates = join(abspath(dirname(argv[0])), "doxygen")
  if not isdir(templates):
    print "Error: No template directory at '%s'" % templates
  # Create the lookup engine for includes
  lookup = TemplateLookup(directories = [ templates, join(templates, "include") ])
  # Generate the index page first
  try:
    template = lookup.get_template("index.html")
    processTemplate(template, join(outdir, "index.html"), lookup)
  except Exception, ex:
    print "Warning: Could not process 'index.html'"
  # Process each item
  for item in ITEMS:
    try:
      template = lookup.get_template("%s.html" % item.kind)
      processTemplate(template, join(outdir, "%s.html" % item.refid), lookup, item)
    except:
      pass

#----------------------------------------------------------------------------
# Main program
#----------------------------------------------------------------------------

if __name__ == "__main__":
  # Check args
  if len(argv) <> 3:
    showUsage();
  # Get the input directory and make sure it exists
  indir = abspath(argv[1])
  if not isdir(indir):
    showUsage("Input directory '%s' does not exist." % indir)
  if not isfile(join(indir, "index.xml")):
    showUsage("Input directory '%s' does not contain 'index.xml'." % indir)
  # Get the output directory and make sure it's empty
  outdir = abspath(argv[2])
  if exists(outdir):
    if not isdir(outdir):
      showUsage("Output path '%s' is  not a directory." % outdir)
    rmtree(outdir, onerror = lambda x, y, z: showUsage("Cannot remove existing directory '%s'" % outdir))
  # Create the output directory
  makedirs(outdir)
  # Now, load the dataset
  loadData(indir)
  print "Documentation types:"
  for key in sorted(ITEMS_BY_KIND.keys()):
    print "%-16s: %d" % (key, len(ITEMS_BY_KIND[key]))
  # Generate the documentation
  print "Generating output files ..."
  generateDocs(outdir)

