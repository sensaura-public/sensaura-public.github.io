#!/usr/bin/env python
#----------------------------------------------------------------------------
from sys import argv
from os import makedirs
from os.path import basename, abspath, isdir, isfile, exists, join, dirname
from shutil import rmtree
from xml.parsers.expat import ParserCreate
from mako.template import Template
from mako.lookup import TemplateLookup
from mako.runtime import Context
from StringIO import StringIO
from traceback import print_exc

ITEMS = dict()
KINDS = dict()
SEQUENCE = 1

#----------------------------------------------------------------------------
# Usage information and error reporting
#----------------------------------------------------------------------------

USAGE = """
Usage:

    %s inputdir outputdir

Where:

    inputdir  - the directory containing the XML files generated by doxygen.
    outputdir - the output directory to place the generated Jekyll files.

IMPORTANT: The output directory will be deleted prior to generating new files.
"""

def showUsage(msg = None):
  """ Show usage information and exit
  """
  if msg is not None:
    print "Error: %s\n" % msg
  print USAGE.strip() % argv[0]
  exit(1)

#----------------------------------------------------------------------------
# Documentation data model
#----------------------------------------------------------------------------

class DocItem:
  def __init__(self, **kwds):
    self.parent = None
    self.children = list()
    self.__dict__.update(kwds)

  def addChild(self, child):
    child.parent = self
    self.children.append(child)

# Items grouped by various conditions
ITEMS = list()
ITEMS_BY_REFID = dict()
ITEMS_BY_KIND = dict()

def addItem(item):
  """ Add a new item
  """
  global ITEMS, ITEMS_BY_REFID, ITEMS_BY_KIND
  ITEMS.append(item)
  ITEMS_BY_REFID[item.refid] = item
  if not ITEMS_BY_KIND.has_key(item.kind):
    ITEMS_BY_KIND[item.kind] = list()
  ITEMS_BY_KIND[item.kind].append(item)

#----------------------------------------------------------------------------
# XML data loading
#----------------------------------------------------------------------------

class BaseParser:
  """ Base implementation of a expat based XML parser
  """

  def __init__(self):
    """ Create the parser and attach hooks
    """
    self._parser = ParserCreate()
    self._parser.StartElementHandler = self._StartElementHandler
    self._parser.EndElementHandler = self._EndElementHandler
    self._parser.CharacterDataHandler = self._CharacterDataHandler
    self._stack = list()
    self._active = None
    # Use this to deliberately ignore tags without displaying output
    self.ignoreTags = list()

  #--------------------------------------------------------------------------
  # Event dispatching
  #--------------------------------------------------------------------------

  def _StartElementHandler(self, name, attributes):
    # Add to the call stack
    self._active = name
    self._stack.append(self._active)
    # Allow custom processing
    methodName = "begin%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if(callable(method)):
      method(name, attributes)
    else:
      if not name in self.ignoreTags:
        print "Unhandled tag '<%s>'" % name

  def _EndElementHandler(self, name):
    # Pop off the call stack
    self._stack = self._stack[:-1]
    if len(self._stack) > 0:
      self._active = self._stack[-1]
    else:
      self._active = None
    # Allow custom processing
    methodName = "end%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if(callable(method)):
      method(name)

  def _CharacterDataHandler(self, data):
    self.processText(self._active, data)

  #--------------------------------------------------------------------------
  # Parsing
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    pass

  def parse(self, filename):
    """ Parse a file
    """
    self.beginParse()
    self._parser.ParseFile(open(filename, "r"))

  def processText(self, name, text):
    """ Called to handle text between tags
    """
    pass

class CompoundParser(BaseParser):
  """ Parser for the index.xml file generated by doxygen

    This builds up the list of top level compound objects and builds the
    initial data for their child members.
  """

  def __init__(self):
    """ Constructor
    """
    BaseParser.__init__(self)
    self.ignoreTags.append("doxygenindex")
    self.ignoreTags.append("name")

  #--------------------------------------------------------------------------
  # Parse handlers
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    self.activeCompound = None
    self.activeMember = None

  def processText(self, name, text):
    if name == "name":
      if self.activeMember is not None:
        self.activeMember.name = self.activeMember.name + text
      elif self.activeCompound is not None:
        self.activeCompound.name = self.activeCompound.name + text

  def beginCompound(self, name, attributes):
    self.activeCompound = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )

  def endCompound(self, name):
    addItem(self.activeCompound)
    self.activeCompound = None

  def beginMember(self, name, attributes):
    self.activeMember = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )
    # Hack: Doxygen treats methods as functions, lets give them their own
    #       kind so we can handle it appropriately
    if (self.activeCompound.kind == "class") and (self.activeMember.kind == "function"):
      self.activeMember.kind = "method"
    # Attach to parent
    self.activeCompound.addChild(self.activeMember)

  def endMember(self, name):
    addItem(self.activeMember)
    self.activeMember = None

#----------------------------------------------------------------------------
# Output generation
#----------------------------------------------------------------------------

def processTemplate(template, outputname, lookup, docItem = None):
  buf = StringIO()
  # Set up the context
  context = Context(buf,
    docItem = docItem,
    docItems = ITEMS,
    docItemsByKind = KINDS
    )
  try:
    template.render_context(context)
    with open(outputname, "w") as output:
      output.write(buf.getvalue())
  except Exception, ex:
    print "Error: Could not generate '%s'" % outputname
    print_exc()

def generateDocs(outdir):
  global ITEMS, KINDS
  # Figure our where our templates are
  templates = join(abspath(dirname(argv[0])), "doxygen")
  if not isdir(templates):
    print "Error: No template directory at '%s'" % templates
  # Create the lookup engine for includes
  lookup = TemplateLookup(directories = [ templates, join(templates, "include") ])
  # Generate the index page first
  try:
    template = lookup.get_template("index.html")
    processTemplate(template, join(outdir, "index.html"), lookup)
  except Exception, ex:
    print "Warning: Could not process 'index.html'"
  # Process each item
  for name in ITEMS.keys():
    item = ITEMS[name]
    try:
      template = lookup.get_template("%s.html" % item.kind)
      processTemplate(template, join(outdir, "%s.html" % item.refid), lookup, item)
    except:
      pass

def loadData(indir):
  """ Load the documentation data from the XML files.
  """
  if not isfile(join(indir, "index.xml")):
    showUsage("Could not find 'index.xml' in input directory")
  parser = CompoundParser()
  parser.parse(join(indir, "index.xml"))


#----------------------------------------------------------------------------
# Main program
#----------------------------------------------------------------------------

if __name__ == "__main__":
  # Check args
  if len(argv) <> 3:
    showUsage();
  # Get the input directory and make sure it exists
  indir = abspath(argv[1])
  if not isdir(indir):
    showUsage("Input directory '%s' does not exist." % indir)
  if not isfile(join(indir, "index.xml")):
    showUsage("Input directory '%s' does not contain 'index.xml'." % indir)
  # Get the output directory and make sure it's empty
  outdir = abspath(argv[2])
  if exists(outdir):
    if not isdir(outdir):
      showUsage("Output path '%s' is  not a directory." % outdir)
    rmtree(outdir, onerror = lambda x, y, z: showUsage("Cannot remove existing directory '%s'" % outdir))
  # Create the output directory
  makedirs(outdir)
  # Now, load the dataset
  loadData(indir)
  print "Documentation types:"
  for key in sorted(ITEMS_BY_KIND.keys()):
    print "%-16s: %d" % (key, len(ITEMS_BY_KIND[key]))
#  # Generate the documentation
#  print "Generating output files ..."
#  generateDocs(outdir)

