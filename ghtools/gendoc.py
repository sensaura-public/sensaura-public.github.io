#!/usr/bin/env python
#----------------------------------------------------------------------------
from sys import argv
from json import loads
from os import makedirs
from os.path import basename, abspath, isdir, isfile, exists, join, dirname, splitext
from shutil import rmtree
from xml.parsers.expat import ParserCreate
from mako.template import Template
from mako.lookup import TemplateLookup
from mako.runtime import Context
from StringIO import StringIO
from traceback import print_exc
from optparse import OptionParser

ITEMS = dict()
KINDS = dict()
SEQUENCE = 1

#----------------------------------------------------------------------------
# Utility functions for template processing
#----------------------------------------------------------------------------

DOCUMENTED_KINDS = list()

def addDocumentedKinds(names):
  """ Add to the list of DocItem kinds that get their own page
  """
  global DOCUMENTED_KINDS
  if type(names) == str:
    if not names in DOCUMENTED_KINDS:
      DOCUMENTED_KINDS.append(names)
  else:
    for name in names:
      if not name in DOCUMENTED_KINDS:
        DOCUMENTED_KINDS.append(name)

def getDocumentedKinds():
  global DOCUMENTED_KINDS
  return DOCUMENTED_KINDS

def getPlural(name):
  """ Get the plural form of the given name
  """
  if len(name) > 0:
    if name[-1] in ("s", "S"):
      name = name + "es"
    else:
      name = name + "s"
  return name.lower().capitalize()

#----------------------------------------------------------------------------
# Usage information and error reporting
#----------------------------------------------------------------------------

USAGE = """
Usage:

    %s inputdir outputdir

Where:

    inputdir  - the directory containing the XML files generated by doxygen.
    outputdir - the output directory to place the generated Jekyll files.

IMPORTANT: The output directory will be deleted prior to generating new files.
"""

def showUsage(msg = None):
  """ Show usage information and exit
  """
  if msg is not None:
    print "Error: %s\n" % msg
  print USAGE.strip() % argv[0]
  exit(1)

#----------------------------------------------------------------------------
# Documentation data model
#----------------------------------------------------------------------------

class Data:
  def __init__(self, **kwds):
    self.__dict__.update(kwds)

class DocItem(Data):
  def __init__(self, **kwds):
    self.parent = None
    self.children = list()
    Data.__init__(self, **kwds)

  def addChild(self, child):
    child.parent = self
    self.children.append(child)

  def getChildrenByKind(self, kind):
    result = list()
    for child in self.children:
      if child.kind == kind:
        result.append(child)
    return result

  def getText(self, *args):
    for name in args:
      value = getattr(self, name, "").strip()
      if len(value) > 0:
        return value
    return ""

  def getDescription(self, alternate = "No description"):
    result = self.getText("briefdescription", "detaileddescription")
    if len(result) == 0:
      result = alternate
    return result

  def getFile(self):
    """ Find the closest file object to this one
    """
    result = self
    while (result is not None) and (result.kind <> "file"):
      result = result.parent
    return result

  def getURL(self):
    """ Find a URL containing the documentation
    """
    result = self
    while (result is not None) and (result.kind not in getDocumentedKinds()):
      result = result.parent
    if result is None:
      return "#"
    if result == self:
      return "%s.html" % result.refid
    return "%s.html#%s" % (result.refid, self.refid)

  def getDisplayName(self):
    if self.kind in ("function", "method"):
      return "%s %s" % (self.definition, self.argsstring)
    return self.name

  def getShortName(self):
    if self.kind in ("function", "method"):
      return self.definition.split(" ")[-1]
    return self.name

  def getParameterDescription(self, name):
    """ Match a description to a parameter name
    """
    if hasattr(self, "paramDesc"):
      for param in self.paramDesc:
        if name in param.names:
          return param.description
    return ""

# Items grouped by various conditions
ITEMS = list()
ITEMS_BY_REFID = dict()
ITEMS_BY_KIND = dict()

def addItem(item):
  """ Add a new item
  """
  global ITEMS, ITEMS_BY_REFID, ITEMS_BY_KIND
  ITEMS.append(item)
  ITEMS_BY_REFID[item.refid] = item
  if not ITEMS_BY_KIND.has_key(item.kind):
    ITEMS_BY_KIND[item.kind] = list()
  ITEMS_BY_KIND[item.kind].append(item)

def getItem(refid):
  global ITEMS_BY_REFID
  return ITEMS_BY_REFID.get(refid, None)

#----------------------------------------------------------------------------
# XML data loading
#----------------------------------------------------------------------------

class BaseParser:
  """ Base implementation of a expat based XML parser
  """

  def __init__(self):
    """ Create the parser and attach hooks
    """
    # Use this to deliberately ignore tags without displaying output
    self.ignoreTags = list()

  #--------------------------------------------------------------------------
  # Event dispatching
  #--------------------------------------------------------------------------

  def _StartElementHandler(self, name, attributes):
    # Add to the call stack
    self._active = name
    self._stack.append(self._active)
    # Allow custom processing
    methodName = "begin%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if callable(method):
      method(name, attributes)
    else:
      if not name in self.ignoreTags:
        method = getattr(self, "begin", None)
        if callable(method):
          method(name, attributes)
        else:
          print "Unhandled tag '<%s>'" % name

  def _EndElementHandler(self, name):
    # Pop off the call stack
    self._stack = self._stack[:-1]
    if len(self._stack) > 0:
      self._active = self._stack[-1]
    else:
      self._active = None
    # Allow custom processing
    methodName = "end%s" % name.capitalize()
    method = getattr(self, methodName, None)
    if callable(method):
      method(name)
    else:
      if not name in self.ignoreTags:
        method = getattr(self, "end", None)
        if callable(method):
          method(name)

  def _CharacterDataHandler(self, data):
    self.processText(self._active, data)

  #--------------------------------------------------------------------------
  # Parsing
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    pass

  def parse(self, filename):
    """ Parse a file
    """
    # Initialise state
    self._stack = list()
    self._active = None
    # Allow custom state initialisation
    self.beginParse()
    # Create a parser and process the file
    parser = ParserCreate()
    parser.StartElementHandler = self._StartElementHandler
    parser.EndElementHandler = self._EndElementHandler
    parser.CharacterDataHandler = self._CharacterDataHandler
    parser.ParseFile(open(filename, "r"))

  def processText(self, name, text):
    """ Called to handle text between tags
    """
    pass

class CompoundParser(BaseParser):
  """ Parser for the index.xml file generated by doxygen

    This builds up the list of top level compound objects and builds the
    initial data for their child members.
  """

  def __init__(self):
    """ Constructor
    """
    BaseParser.__init__(self)
    # Ignore these tags, we don't use them
    self.ignoreTags.append("doxygenindex")
    self.ignoreTags.append("name")
    # Build up a set of top level sources
    self.sources = list()

  #--------------------------------------------------------------------------
  # Parse handlers
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    self.activeCompound = None
    self.activeMember = None

  def processText(self, name, text):
    if name == "name":
      if self.activeMember is not None:
        self.activeMember.name = self.activeMember.name + text
      elif self.activeCompound is not None:
        self.activeCompound.name = self.activeCompound.name + text

  def beginCompound(self, name, attributes):
    self.activeCompound = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )
    addItem(self.activeCompound)
    # Each compound entry has a detail file associated with it
    self.sources.append("%s.xml" % self.activeCompound.refid)

  def endCompound(self, name):
    self.activeCompound = None

  def beginMember(self, name, attributes):
    self.activeMember = DocItem(
      refid = attributes['refid'],
      kind = attributes['kind'],
      name = ""
      )
    addItem(self.activeMember)
    # Hack: Doxygen treats methods as functions, lets give them their own
    #       kind so we can handle it appropriately
    if (self.activeCompound.kind == "class") and (self.activeMember.kind == "function"):
      self.activeMember.kind = "method"
    # Attach to parent
    self.activeCompound.addChild(self.activeMember)

  def endMember(self, name):
    self.activeMember = None

class DetailParser(BaseParser):
  """ Parser for the subsiduary XML files generated by doxygen
  """

  DESCRIPTION_TAGS = (
    "name",
    "title",
    "briefdescription",
    "detaileddescription",
    "type",
    "definition",
    "argsstring",
    "inbodydescription",
    "declname",
    "initializer",
    )

  def __init__(self):
    """ Constructor
    """
    BaseParser.__init__(self)
    # Ignore these tags, we don't use them
    self.ignoreTags.append("codeline")
    self.ignoreTags.append("highlight")
    self.ignoreTags.append("sp")

  #--------------------------------------------------------------------------
  # Helpers
  #--------------------------------------------------------------------------

  def clearText(self):
    self.text = list()

  def addText(self, text):
    self.text.append(text)

  def getText(self):
    return " ".join(self.text)

  #--------------------------------------------------------------------------
  # Parse handlers
  #--------------------------------------------------------------------------

  def beginParse(self):
    """ Called prior to parsing. Use this to reset internal state
    """
    # Set state
    self.activeCompound = None
    self.activeItem = None
    self.activeTag = None
    self.text = list()

  def processText(self, name, text):
    self.addText(text)

  def beginCompounddef(self, name, attributes):
    self.activeCompound = getItem(attributes['id'])

  def endCompounddef(self, name):
    self.activeCompound = None

  def beginIncludes(self, name, attributes):
    fileref = getItem(attributes.get('refid', None))
    if (fileref is None) or (self.activeCompound is None) or (self.activeCompound.parent is not None):
      return
    self.activeCompound.parent = fileref
    fileref.addChild(self.activeCompound)

  def beginMemberdef(self, name, attributes):
    self.activeItem = getItem(attributes['id'])
    if self.activeItem is None:
      print "Warning: reference to unknown item '%s'" % attributes['id']
      return
    # Add attributes to the item
    for k in attributes.keys():
      if k not in ("kind", "id"):
        setattr(self.activeItem, k, attributes[k])
    # Set defaults for descriptions
    for desc in DetailParser.DESCRIPTION_TAGS:
      setattr(self.activeItem, desc, "")

  def endMemberdef(self, name):
    self.activeItem = None

  def beginEnumvalue(self, name, attributes):
    enumValue = DocItem(
      parent = self.activeItem,
      refid = attributes['id'],
      prot = attributes.get('prot', "")
      )
    self.activeItem.addChild(enumValue)
    self.activeItem = enumValue

  def endEnumvalue(self, name):
    self.activeItem = self.activeItem.parent

  def beginRef(self, name, attributes):
    target = getItem(attributes['refid'])
    self.addText('<a href="%s">' % target.getURL())

  def endRef(self, name):
    self.addText('</a>')

  def beginSect1(self, name, attributes):
    self.activeItem = DocItem(
      refid = attributes['id'],
      kind = "sect1",
      text = self.text
      )
    self.clearText()
    self.activeCompound.addChild(self.activeItem)

  def endSect1(self, name):
    text = self.getText()
    self.text = self.activeItem.text
    self.activeItem.text = text
    self.activeItem = None

  def beginSect2(self, name, attributes):
    section = DocItem(
      refid = attributes['id'],
      kind = "sect2",
      text = self.text
      )
    self.clearText()
    self.activeItem.addChild(section)
    self.activeItem = section

  def endSect2(self, name):
    text = self.getText()
    self.text = self.activeItem.text
    self.activeItem.text = text
    self.activeItem = self.activeItem.parent

  def beginSimplesect(self, name, attributes):
    kind = attributes['kind']
    if kind == "return":
      self.activeItem = DocItem(parent = self.activeItem, kind = "simplesect", name = "returns", text = self.text)
      self.clearText()

  def endSimplesect(self, name):
    if (self.activeItem is not None) and (self.activeItem.kind == "simplesect"):
      section = self.activeItem
      self.activeItem = section.parent
      setattr(self.activeItem, section.name, self.getText())
      self.text = section.text

  def beginParam(self, name, attributes):
    self.activeItem = DocItem(
      parent = self.activeItem,
      declname = "",
      type = ""
      )

  def endParam(self, name):
    param = self.activeItem
    self.activeItem = param.parent
    if not hasattr(self.activeItem, "params"):
      self.activeItem.params = list()
    self.activeItem.params.append(param)

  def beginParameterlist(self, name, attributes):
    self.activeItem.paramDesc = list()

  def endParameterlist(self, name):
    pass

  def beginParameteritem(self, name, attributes):
    param = DocItem(
      parent = self.activeItem,
      names = list(),
      description = "",
      text = self.text
      )
    self.activeItem.paramDesc.append(param)
    self.activeItem = param
    self.clearText()

  def endParameteritem(self, name):
    self.text = self.activeItem.text
    del self.activeItem.text
    self.activeItem = self.activeItem.parent

  def beginParametername(self, name, attributes):
    self.clearText()

  def endParametername(self, name):
    self.activeItem.names.append(self.getText())

  def beginParameterdescription(self, name, attributes):
    self.clearText()

  def endParameterdescription(self, name):
    self.activeItem.description = self.getText()

  def begin(self, name, attributes):
    if name in DetailParser.DESCRIPTION_TAGS:
      self.clearText()

  def end(self, name):
    if (name in DetailParser.DESCRIPTION_TAGS):
      if self.activeItem is not None:
        setattr(self.activeItem, name, self.getText())
      elif self.activeCompound is not None:
        # Add extra values (but don't overwrite)
        if len(getattr(self.activeCompound, name, "")) == 0:
          setattr(self.activeCompound, name, self.getText())
      self.clearText()


def loadData(indir, config):
  """ Load the documentation data from the XML files.
  """
  print "Processing input ..."
  if not isfile(join(indir, "index.xml")):
    showUsage("Could not find 'index.xml' in input directory")
  # Set up the documented kinds (from config file)
  if hasattr(config, "documented"):
    addDocumentedKinds(config.documented)
  # Process the index file
  parser = CompoundParser()
  print "  index.xml"
  parser.parse(join(indir, "index.xml"))
  # Now do all the detail files
  sources = parser.sources
  parser = DetailParser()
  for source in sources:
    print "  %s" % source
    parser.parse(join(indir, source))

#----------------------------------------------------------------------------
# Output generation
#----------------------------------------------------------------------------

def processTemplate(template, outputname, lookup, config, docItem = None):
  global ITEMS, ITEMS_BY_KIND, ITEMS_BY_REFID
  # Set up the context
  buf = StringIO()
  context = Context(buf,
    config = config,
    docItem = docItem,
    docItems = ITEMS,
    docItemsByKind = ITEMS_BY_KIND,
    docItemsByRefId = ITEMS_BY_REFID,
    # Utility functions
    getPlural = getPlural,
    addDocumentedKinds = addDocumentedKinds,
    getDocumentedKinds = getDocumentedKinds,
    )
  try:
    template.render_context(context)
    with open(outputname, "w") as output:
      output.write(buf.getvalue())
  except Exception, ex:
    print "Error: Could not generate '%s'" % outputname
    print docItem.__dict__
    print_exc()

def generateDocs(outdir, config):
  global ITEMS
  # Figure our where our templates are
  templates = join(abspath(dirname(argv[0])), "doxygen")
  if not isdir(templates):
    print "Error: No template directory at '%s'" % templates
  # Create the lookup engine for includes
  lookup = TemplateLookup(directories = [ templates, join(templates, "include") ])
  # Generate the index page first
  item = getItem("indexpage")
  try:
    template = lookup.get_template("index.html")
    processTemplate(template, join(outdir, "index.html"), lookup, config, item)
  except Exception, ex:
    print "Warning: Could not process 'index.html'"
  # Process each item
  for item in ITEMS:
    try:
      template = lookup.get_template("%s.html" % item.kind)
      processTemplate(template, join(outdir, "%s.html" % item.refid), lookup, config, item)
    except:
      pass

#----------------------------------------------------------------------------
# Main program
#----------------------------------------------------------------------------

def fromJSONFile(filename):
  """ Deserialise JSON from a file
  """
  # Add extension if needed
  if splitext(filename)[1] == "":
    filename = filename + ".json"
  lines = list()
  with open(filename, "r") as config:
    for line in config:
      clean = line.strip()
      if clean.startswith("#") or clean.startswith("//"):
        lines.append("")
      else:
        lines.append(line)
  return loads("\n".join(lines))

if __name__ == "__main__":
  # Process command line arguments
  parser = OptionParser()
  parser.add_option("-c", "--config", action="store", type="string", dest="config")
  options, args = parser.parse_args()
  # Check args
  if len(args) <> 2:
    showUsage()
  # Load the configuration if specified
  config = dict()
  if options.config is not None:
    config = fromJSONFile(options.config)
  config = Data(**config)
  # Get the input directory and make sure it exists
  indir = abspath(args[0])
  if not isdir(indir):
    showUsage("Input directory '%s' does not exist." % indir)
  if not isfile(join(indir, "index.xml")):
    showUsage("Input directory '%s' does not contain 'index.xml'." % indir)
  # Get the output directory and make sure it's empty
  outdir = abspath(args[1])
  if exists(outdir):
    if not isdir(outdir):
      showUsage("Output path '%s' is  not a directory." % outdir)
    rmtree(outdir, onerror = lambda x, y, z: showUsage("Cannot remove existing directory '%s'" % outdir))
  # Create the output directory
  makedirs(outdir)
  # Now, load the dataset
  loadData(indir, config)
  print "Documentation types:"
  for key in sorted(ITEMS_BY_KIND.keys()):
    print "%-16s: %d" % (key, len(ITEMS_BY_KIND[key]))
  # Generate the documentation
  print "Generating output files ..."
  generateDocs(outdir, config)

