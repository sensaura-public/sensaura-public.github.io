---
title: The Evolving SensHub Architecture
category: senshub
cover: 2016/03/04/senshub_architecture_2.png
textcolor: black
---
While working on a project I like to evaluate implementations and ideas done by others in the same space (like the comparison to the Riots system [I posted earlier](http://sensaura.org/sensnode/2016/01/15/riots-plug-and-play-iot.html)) - quite often this leads to improvements to my own code and designs, sometimes minor and sometimes fairly major. I've been following the JeeLabs blog for a while now (he does a lot of work with similar goals to mine) so when he started a series of posts on the [JeeLabs JET](http://jeelabs.org/article/1604a/) sensor hub implementation it seemed like a good idea to compare it to my own [SensHub design](http://sensaura.org/pages/senshub/index.html). That comparison has lead to some major design changes to SensHub which have kept me occupied for the past month.

The JET system is still in early stages of development - the code is [available on GitHub](https://github.com/jeelabs/jet) but there is not a lot of functionality available at this stage and, apart from some command line utilities, not a lot of tools available to interact with it. The most interesting aspect of JET is that it uses MQTT for all interaction between components, not just for transferring sensor data and actuator commands. This approach makes the system extremely flexible - a extension module (in the JeeLabs system these are called JET Packs) does not need to run in the same process, or even on the same computer, as the hub. As long as it can communicate with the same MQTT server the hub is using it can participate and provide services to the rest of the system. [This article](http://jeelabs.org/article/1603c/) describes how that design come about. This is a very powerful concept and makes the system hugely extensible.

When I saw this I realised that it could be applied to the SensHub systemwith some minor changes. The original SensHub architecture allowed for plugins and extensions to be added but was far more restrictive on how they were implemented and how they interacted with the rest of the system. The diagram below shows how it is set up

![Original SensHub Architecture](/images/2016/03/04/senshub_architecture_1.png)

SensHub was designed to run as a single process and extensions were implemented as shared libraries that were loaded into the processes memory space at startup. Interaction between the hub and the extensions was done through an API defined as a set of interfaces - a plugin was required to implement at least one of these to be recognised as an extension and could optionally implement others to provide additional functionality. The MQTT support was limited, it was simply a method of exchanging data with sensors that were not directly supported by a SensHub plugin. The primary data distribution was done on the internal MessageBus (which used a similar model as MQTT anyway) - a plugin simply replicated data published to a specific MessageBus topic to an external MQTT server and subscribed to a MQTT topic for data to put on the MessageBus.

Once I started implementing real world solutions with the system a number of problems came up:

1. Because I chose to use C# and the .NET runtime for the hub implementation extensions can only be written in languages that were capable of generating a .NET assembly which could be dynamically loaded. This introduces an arbitrary limit on the tools that could be used to extend the system and, as I found out while building plugins to interact with hardware, lead to portability issues especially when you needed to use native code to access GPIO ports.
2. The system was fragile - a bug in an extension could bring the entire hub process down and remove access to all functionality rather than just the buggy implementation.
3. I wanted to build a version of SensHub for the Windows 10 IoT platform to make it easier to deploy and try without requiring a lot of Linux experience. Applications on this platform cannot load external assemblies that were not deployed as part of the application package meaning that if a plugin was not built in to the application there would be no way for the user to add new functionality.

The JET approach of using MQTT for all interactions, not just data, resolves all of these issues and applying that approach to the SensHub architecture is not all that difficult. The diagram below shows what it would look like.

![New SensHub Architecture](/images/2016/03/04/senshub_architecture_2.png)

In this design MQTT is the glue that holds everything together - as well as transporting data to and from sensors it is now used to allow extensions to discover and interact with each other. The old model of a single process with a group of extensions running inside it is still supported (and the core hub will probably still be implemented this way) but now extensions can be run as separate processes on any device on the network. Extensions that are available advertise themselves over MQTT and consumers of the services they provide can interact with them the same way - this allows extensions to be written in any language that supports communicating with an MQTT server and deployed to any device with networking capability - removing the technology restrictions in the older design. This dramatically changes what a SensHub system looks like - there is no real hub any more as the services can be spread across multiple nodes, the designation of a single device as the hub is more a naming convention than identifying a single critical component of the system.

The interaction between the components can be described by a small set of common design patterns (which I will cover in a future post) and in my current prototype I have wrapped up in a library to help simplify the development of new components. I have also written a separate tool to help manage extensions - at the moment this is a simple Python script that determines the appropriate MQTT server to communicate with, launches one or more extension executables (based on a configuration file) and then uses the discovery features of the system to ensure they are running (restarting them if necessary). The current prototype is working well (a pleasant side effect is that it's a lot easier to debug and extend - extensions that are known to work are left running on a 'stable' server, extensions under development can be started and stopped as needed on my development machine) and I'm in the process of cleaning up the Python version and refactoring the existing C# code to use the new model.

These changes are going to require a reworking of the current source repository layout - I'll be rolling out these changes over the coming weeks.
